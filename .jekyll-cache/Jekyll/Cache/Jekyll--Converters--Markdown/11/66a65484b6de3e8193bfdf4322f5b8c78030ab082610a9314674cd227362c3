I"†B<p>Some of the most meaningful mathematical realizations that I‚Äôve had have been
unexpected connections between two topics; that is, realizing that two concepts
that first appeared quite distinct are in fact one and the same. In our first
linear algebra courses, we learn that manipulations of matrices is, in fact,
equivalent to solving systems of equations. In quantum mechanics, we see that
<a href="https://en.wikipedia.org/wiki/Observable">physically observable quantities</a> are, mathematically speaking, linear
operators (I still don‚Äôt quite grok this one). And, my personal favorite
example, we learn in functional analysis that the linear functionals in the dual
space of a Hilbert space are themselves in perfect correspondence with the
functions in the original space.<sup id="fnref:fnote1" role="doc-noteref"><a href="#fn:fnote1" class="footnote" rel="footnote">1</a></sup></p>

<p>Recently, I‚Äôve stumbled upon another such result, which has captured my
attention for a while. The result, often referred to as Curry-Howard
correspondence, is the statement that propositions in a formal logical system
are equivalent to types in the simply typed lambda calculus. Loosely, this means
that <strong>logical statements are equivalent to data types</strong>!</p>

<p>Let‚Äôs unpack that a bit; ‚Äúpropositions‚Äù are just statements in a logical
system.<sup id="fnref:fnote15" role="doc-noteref"><a href="#fn:fnote15" class="footnote" rel="footnote">2</a></sup> In mathematics, for example, one might put forward the
proposition ‚Äúno even numbers are prime,‚Äù or ‚Äú14 is greater than 18‚Äù. Note that
propositions need not be <em>true</em>; in fact, some logical systems support
propositions that cannot even be determined to be true or false.<sup id="fnref:fnote2" role="doc-noteref"><a href="#fn:fnote2" class="footnote" rel="footnote">3</a></sup>
‚ÄúTypes‚Äù can be though of as types in a computing language; <code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">Boolean</code>,
and so on. We will have much more to say about types as we move forward, but for
now, hold in your mind the conventional notion of types as defined in a language
such as Java or Python (or better yet, Haskell).</p>

<p>How on earth could these two be in correspondence? On the surface, they appear
entirely separate concepts. In this post, I‚Äôll spend some time unpacking what
this equivalence is actually saying, using a simple example. I am far from a
full understanding of it, but as usual, I write about it in the hopes that I‚Äôll
be forced to clarify what I <em>do</em> understand, or even better, be corrected by
someone more knowledgable than myself.</p>

<p>Speaking of those more knowledgable than myself, there are various resources
online that I found very helpful in understanding the correspondence:
<a href="https://www.youtube.com/watch?v=IOiZatlZtGU&amp;t=1176s">Philip Wadler‚Äôs talk</a> on the subject is a great starting point, and there
are a number of <a href="http://lambda-the-ultimate.org/node/1532">useful</a> <a href="https://stackoverflow.com/questions/2969140/what-are-the-most-interesting-equivalences-arising-from-the-curry-howard-isomorp">discussions</a> <a href="https://stackoverflow.com/questions/2829347/a-question-about-logic-and-the-curry-howard-correspondence">available</a> on StackExchange and
various functional programming forums.</p>

<h2 id="an-example">An Example</h2>

<p>I was confused by the idea of propositions as types when I first encountered it,
and after learning more, I believe that the root of my confusion lies in the
fact that types such as <code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">Boolean</code>, and <code class="language-plaintext highlighter-rouge">String</code>, which we are
familiar with from programming, correspond to very trivial propositions, making
them poor examples. We‚Äôll have to introduce something a bit fancier; a
<em>conditional type</em>. For example, <code class="language-plaintext highlighter-rouge">OddInt</code> might be odd Integers, and <code class="language-plaintext highlighter-rouge">PrimeInt</code>
might be prime integers. We‚Äôll approximate these conditional types with custom
classes in Scala. Classes and types are <a href="https://stackoverflow.com/questions/5031640/what-is-the-difference-between-a-class-and-a-type-in-scala-and-java">different beasts</a>, of course, but
we will ignore that distinction in this post.<sup id="fnref:fnote3" role="doc-noteref"><a href="#fn:fnote3" class="footnote" rel="footnote">4</a></sup></p>

<p>Let‚Äôs consider one conditional type in particular: <code class="language-plaintext highlighter-rouge">BigInteger</code>. This type
(actually a class in this example) is defined as follows:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">BigInteger</span> <span class="o">(</span><span class="k">val</span> <span class="nv">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">final</span> <span class="k">val</span> <span class="nv">LOWER_BOUND</span> <span class="k">=</span> <span class="mi">10000</span>
  
  <span class="nf">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="nc">LOWER_BOUND</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Too small!"</span><span class="o">)</span>
  <span class="o">}</span>
  
  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="n">s</span><span class="s">"BigInteger($value)"</span>

<span class="o">}</span></code></pre></figure>

<p>One could then instantiate a <code class="language-plaintext highlighter-rouge">BigInteger</code> as follows:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nv">big</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">10001</span><span class="o">)</span>
<span class="c1">// res0: BigInteger(10001)</span>

<span class="k">val</span> <span class="nv">small</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">500</span><span class="o">)</span>
<span class="c1">// java.lang.IllegalArgumentException: Too small!</span></code></pre></figure>

<p>Now the fundemanetal question: what proposition corresponds to this type?  In
simple scenarios like this, the corresponding proposition is that the type can
be <em>inhabited</em>; that is, there exists a value that satisfies that type. For
example, the type <code class="language-plaintext highlighter-rouge">BigInteger</code> corresponds to the claim ‚Äúthere exists an integer
\(i\) for which \( i &gt; 10,000 \)‚Äù. Obviously, such an integer exists, and the
fact that we can instantiate this type indicates that it corresponds to a true
proposition. Alternatively, consider a type <code class="language-plaintext highlighter-rouge">WeirdInteger</code>, which is an integer
satisfying <code class="language-plaintext highlighter-rouge">i &lt; 3 &amp;&amp; i &gt; 5</code>. We can define the type well enough, but there are
no values which satisfy it; it is an uninhabitable type, and so corresponds to a
false proposition.</p>

<h2 id="functions-and-implication">Functions and Implication</h2>

<p>Let‚Äôs make things a little more interesting. In programming languages, there are
not only primitive types like <code class="language-plaintext highlighter-rouge">Integer</code> and <code class="language-plaintext highlighter-rouge">Boolean</code>, but there are also
<strong>function types</strong>, which are the types of functions. For example, in Scala, the
function <code class="language-plaintext highlighter-rouge">def f(x: Int) = x.toString</code> has type <code class="language-plaintext highlighter-rouge">Int =&gt; String</code>, which is to say
it is a function that maps integers to strings.</p>

<p>What sort of propositions would <em>functions</em> correspond to? It turns out that
functions naturally map to <em>implication</em>. In some ways, the correspondence here
is very natural. Consider the conditional type <code class="language-plaintext highlighter-rouge">BigInteger</code>, and the conditional
type <code class="language-plaintext highlighter-rouge">BiggerInteger</code>. The definition of the latter should look familiar, from
above:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">BiggerInteger</span> <span class="o">(</span><span class="k">val</span> <span class="nv">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">final</span> <span class="k">val</span> <span class="nv">LOWER_BOUND</span> <span class="k">=</span> <span class="mi">20000</span>
  
  <span class="nf">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="nc">LOWER_BOUND</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Too small!"</span><span class="o">)</span>
  <span class="o">}</span>
  
  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="n">s</span><span class="s">"BiggerInteger($value)"</span>

<span class="o">}</span></code></pre></figure>

<p>Now, we can write a function that maps <code class="language-plaintext highlighter-rouge">BigInteger</code> to <code class="language-plaintext highlighter-rouge">BiggerInteger</code>:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="nf">makeBigger</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BigInteger</span><span class="o">)</span><span class="k">:</span> <span class="kt">BiggerInteger</span> <span class="o">=</span> 
  <span class="k">new</span> <span class="nc">BiggerInteger</span><span class="o">(</span><span class="nv">b</span><span class="o">.</span><span class="py">value</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span></code></pre></figure>

<p>Recall that the proposition corresponding to the type <code class="language-plaintext highlighter-rouge">BigInteger</code> is the
statement ‚Äúthere exists an integer greater than 10,000‚Äù, and the proposition
corresponding to <code class="language-plaintext highlighter-rouge">Bigger</code> is the statement ‚Äúthere exists an integer greater than
20,000‚Äù; the proposition corresponding to the function type <code class="language-plaintext highlighter-rouge">BigInteger =&gt;
BiggerInteger</code> is then just the statement ‚Äúthe existence of an integer above
10,000 implies the existence of an integer above 20,000‚Äù. And note that, as it
should be for an implication, we do not care whether there actually <em>does</em> exist
an integer above 10,000; we simply know that <em>if</em> one exists, then its existence
implies the existence of an integer above 20,000.</p>

<p>To be a bit more explicit, the function that we wrote above can be thought of as
a <strong>proof</strong> of the implication; in particular, if we suppose that there exists
an \(i\) such that \(i &gt; 10,000\), then clearly \(2i &gt; 20,000\), and so
if we let \(j=2i\), then we have proven the existence of a \(j\) such that
\(j &gt; 20,000\). This is what the theoretical computer scientists mean when
they say that ‚Äúprograms are proofs‚Äù.</p>

<p>Of course, Scala is not a proof-checking language, and cannot tell during
compilation that the function <code class="language-plaintext highlighter-rouge">makeBigger</code> is valid; we would need a much richer
type system to be able to validate such functions. Consider that the following
function compiles with no problem, although there are no input values for which
it will not throw a (runtime) exception:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="nf">wonky</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">BigInteger</span><span class="o">)</span><span class="k">:</span> <span class="kt">BiggerInteger</span> <span class="o">=</span> 
  <span class="k">new</span> <span class="nc">BiggerInteger</span><span class="o">(</span><span class="nv">b</span><span class="o">.</span><span class="py">value</span> <span class="o">%</span> <span class="mi">1000</span><span class="o">)</span></code></pre></figure>

<h3 id="wait-what">Wait‚Ä¶ what?</h3>

<p>If you think about it a bit more, it‚Äôs sort of a weird example; you
could map <em>any</em> type to <code class="language-plaintext highlighter-rouge">BiggerInteger</code>, just by doing <code class="language-plaintext highlighter-rouge">def f[A](a:A):
BiggerInteger = new BiggerInteger(20001)</code>. This is because the proposition that
corresponds to <code class="language-plaintext highlighter-rouge">BiggerInteger</code> is true (the type is inhabitable), and if B is
true, then A implies B for any A at all.</p>

<p>Common languages such as Haskell only express very trivial propositions with
their types; there does exist one uninhabitable type (<code class="language-plaintext highlighter-rouge">void</code>), but I have not
found much use for it in practice. The benefit of using conditional types for
these examples is that we can explore at least some types which have
corresponding <em>false</em> propositions, such as <code class="language-plaintext highlighter-rouge">WeirdInteger</code>, which are integers
<code class="language-plaintext highlighter-rouge">i</code> which satisfy <code class="language-plaintext highlighter-rouge">i &lt; 3 &amp;&amp; i &gt; 5</code>.</p>

<h2 id="in-conclusion">In Conclusion</h2>

<p>Seeing all this, you can begin to get a sense of how computer-assisted proof
techniques might arise out of it. If the fact that a program compiles is
equivalent to the truth the corrsponding proposition, then all we need is a
language with a rich enough type system to express interesting
statements. Examples of languages used in this way include <a href="https://coq.inria.fr/">Coq</a> and
<a href="https://en.wikipedia.org/wiki/Agda_(programming_language">Agda</a>. A thorough discussion of such languages is beyond both the scope of
this post and my understanding.</p>

<p>I think what keeps me interested in this subject is that it still remains quite
opaque to me; I‚Äôve struggled to even come up with these simple (and flawed)
examples of how Curry-Howard correspondence plays out in practice. I hope that
anyone reading this who understand the subject better than I do will leave a
detailed list of my misunderstandings, so that I can better grasp this
mysterious and fascinating topic.</p>

<!-------------------------------- FOOTER ---------------------------->

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fnote1" role="doc-endnote">
      <p>This statement is difficult to understand without background in
functional analysis, but it is in fact one of the most beautiful examples of
such an equivalence result.¬†<a href="#fnref:fnote1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote15" role="doc-endnote">
      <p>I‚Äôm being a bit sloppy here. The type of logic we‚Äôre talking about
here is not classical logic, but rather in the sense of <a href="https://en.wikipedia.org/wiki/Natural_deduction">natural deduction</a>.¬†<a href="#fnref:fnote15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote2" role="doc-endnote">
      <p>Such systems are called undecidable; see
<a href="https://en.wikipedia.org/wiki/Decidability_(logic)">the wiki entry on decidability</a> for more information.¬†<a href="#fnref:fnote2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote3" role="doc-endnote">
      <p>We won‚Äôt be careful about whether the idea of conditional types
presented here corresponds well with conditional types as they are actually
implemented in programming languages such as <a href="https://github.com/Microsoft/TypeScript/pull/21316">Typescript</a>.¬†<a href="#fnref:fnote3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET