I"Ë“<p>This post continues my series on data science interviews. One of the major difficulty of
doing data science interviews is that you must show expertise in a wide variety of
skills. In particular, I see four key subject areas that you might be asked about during
an interview:</p>

<ol>
  <li>Statistics</li>
  <li>Software Engineering/Coding</li>
  <li>Machine Learning</li>
  <li>‚ÄúSoft‚Äù Questions</li>
</ol>

<p>This post focuses on software engineering &amp; coding. It will be primarily a resource for
aggregating content that I think you should be familiar with. I will mostly point to
outside sources for technical exposition and practice questions.</p>

<p>I‚Äôll link to these as appropriate throughout the post, but I thought it would be helpful
to put up front a list of the primary resources that I‚Äôve used when studying for
interviews. Some of my favorites are:</p>

<ul>
  <li><a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">Data Structures and Algorithms in Python</a>, for a good introduction to
data structures such as linked lists, arrays, hashmaps, and so on. It also can give
you good sense of how to write idiomatic Python code, for building fundamental
classes.</li>
  <li><a href="https://sqlzoo.net/">SQLZoo</a> for studying SQL and doing practice questions. I particularly like
the ‚Äúassessments‚Äù.</li>
  <li><a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a> for lots of practice questions organized by
subject, and good general advice for the technical interviewing process.</li>
</ul>

<p>I also use coding websites like LeetCode to practice various problems. I also look on
Glassdoor to see <a href="https://www.glassdoor.com/Interview/san-francisco-data-scientist-interview-questions-SRCH_IL.0,13_IM759_KO14,28.htm">what kinds of problems</a> people have been asked.</p>

<p>As always, I‚Äôm working to improve this post, so please do leave comments with feedback.</p>

<h1 id="what-languages-should-i-know">What Languages Should I Know?</h1>

<p>In this section of data science interviews, your are generally asked to implement things
in code. So, which language should you do it in? Generally, the best answer is
(unsurprisingly) that <strong>you should work in Python</strong>. The next most popular choice is R;
I‚Äôm not very familiar with R, so I can‚Äôt really speak to it‚Äôs capabilities.</p>

<p>There are a few reasons you should work in Python:</p>

<ol>
  <li>It‚Äôs widely adopted within industry.</li>
  <li>It has high-quality, popular packages for working with data (see <code class="language-plaintext highlighter-rouge">pandas</code>, <code class="language-plaintext highlighter-rouge">numpy</code>,
<code class="language-plaintext highlighter-rouge">scipy</code>, <code class="language-plaintext highlighter-rouge">statsmodels</code>, <code class="language-plaintext highlighter-rouge">scikit-learn</code>, <code class="language-plaintext highlighter-rouge">matplotlib</code>, etc).</li>
  <li>It bridges the gap between academic work (e.g. using NumPy to build a fast solver for
differential equations) and industrial work (e.g. using Django to build webservices).</li>
</ol>

<p>This is far from an exhaustive list. Anyways, I mostly work in Python. I think it‚Äôs a
nice language because it is clear and simple to write.</p>

<p>If you want to use another language, you should make sure that you can do everything you
need to - this includes reading &amp; writing data, cleaning/munging data, plotting,
implementing statistical and machine learning models, and leveraging basic data types
like hashmaps and arrays (more on those later).</p>

<p>I think if you wanted to do your interviews in R it would be fine, so long as you can do
the above. I would strongly recommend against languages like MATLAB, which are
proprietary and not open-source.</p>

<p>Languages like Java can be tricky since they might not have the data-oriented libraries
that Python has. For example, I‚Äôve worked profesionally in Scala, and am very
comfortable manipulating data via the Spark API within it, but still wouldn‚Äôt want to
have to use it in an interview; it just isn‚Äôt as friendly for general-purpose hacking as
Python.</p>

<p>So is Python all you need? Well, not quite. You should also be familiar with SQL for
querying databases; we‚Äôll get into that later. I don‚Äôt think the dialect you use
particularly matters. <a href="https://sqlzoo.net/">SQLZoo</a> works with MySQL, which is fine. Familiarity with
bash and shell-scripting is useful for a data scientist in their day-to-day work, but
generally isn‚Äôt asked about in interviews. For the interviews, I‚Äôd say if you know one
general-purpose language (preferably Python, or R if need be) and SQL, then you‚Äôll be
fine.</p>

<h1 id="general-tips-for-coding-interviews">General Tips for Coding Interviews</h1>

<p>Coding interviews are notorious for being high-stress, so it‚Äôs important that you
practice in a way that will maximize your comfort during the interview itself - you
don‚Äôt want to add any unnecessary additional stress into an already difficult
situation. There are a wide variety of philosophies and approaches to preparing yourself
for and executing a successful interview. I‚Äôm going to talk about some points that
resonate with me, but I‚Äôd also recommend reading <a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a>
for a good discussion. Of course, this isn‚Äôt the final word on the topic - there are
endless resources available online that address this.</p>

<h2 id="how-to-prepare">How to Prepare</h2>

<p>When preparing for the interview, make sure to practice in an environment similar to the
interview environment. There are a few aspects of this to keep in mind.</p>

<ul>
  <li>Make sure that you replicate the <strong>writing environment</strong> of the interview. So, if
you‚Äôll be coding on a whiteboard, try to get access to a whiteboard to practice. At
least practice on a pad of paper, so that you‚Äôre comfortable with handwriting code -
it‚Äôs really quite different than using a text editor. If you‚Äôll be coding in a Google
Doc, practice doing that (protip: used a monospaced font). Most places I‚Äôve
interviewed at don‚Äôt let you evaluate your code to test it, so you have to be prepared
for that.</li>
  <li><strong>Time yourself!</strong> It‚Äôs important to make sure you can do these things in a reasonable
amount of time. Generally, these things last 45 minutes per ‚Äúround‚Äù (with multiple
rounds for on-site interviews). Focus on being efficient at implementing simple ideas,
so that you don‚Äôt waste a bunch of time with your syntax and things like that.</li>
  <li><strong>Practice talking.</strong> If you practice by coding silently by yourself, then it might
feel strange when you‚Äôre in the interview and have to talk through your process. The
best is if you can have a friend who is familiar with interviewing play the
interviewer, so that you can talk to them, get asked questions, etc. You can also
record yourself and just talk to the recorder, so that you get practice externalizing
your thoughts.</li>
</ul>

<p>There are some services online that will do ‚Äúpractice‚Äù interviews for you. When I was
practicing for a software engineer interview with Google, I used <a href="http://www.gainlo.co/#!/">Gainlo</a> for
this - they were kind of expensive, but you interview with real Google software
engineers, which I found helpful.</p>

<p>However, the interviews for a software engineering position at Google are very
standardized in format. I haven‚Äôt used any of the services that do this for data
science, and the interviews you‚Äôll face are so varied. Therefore, I imagine it is harder
to do helpful ‚Äúmock interviews‚Äù. If you‚Äôve used any of these services, I‚Äôd be very
curious to hear about your experience.</p>

<h2 id="tips-for-interviewing">Tips for Interviewing</h2>

<p>There are some things it‚Äôs important to keep in mind as you do the interview itself.</p>

<ul>
  <li><strong>Talk about your thought process.</strong> Don‚Äôt just sit sliently thinking, then go and
write something on the board. Let the interviewer into your mind so that they can see
how you are thinking about the problem. This is good advice at any point in a
technical interview.</li>
  <li><strong>Start with a simple solution you have confidence in.</strong> If you know that you can
quickly write up a suboptimal solution (in this case, maybe insertion sort), then do
that! You can discuss <em>why</em> that solution is sub-optimal, and they will often
brainstorm with you about how to improve it. That said, if you are just as confident
in writing up something more optimal (say, quicksort) then feel free to jump right to
that.</li>
  <li><strong>Sketch out your solution before doing real code.</strong> This is not necessary, but
sometimes for complicated stuff it‚Äôs nice to write out your approach in pseudocode
before jumping into real code. This can also help with exposing your thought process
to the interviewer, and making sure they‚Äôre on board with how you‚Äôre thinking about
it.</li>
  <li><strong>Think about edge cases.</strong> Suppose they ask you to write a function that sorts a
list. What if you‚Äôre given an empty list? What if you‚Äôre given a list of
non-comparable things? (In Python, this might be a list of lists.) What does your
function do in this case?  Is that what you <em>want</em> it to do? There‚Äôs no right answer
here, but you should definitely be thinking about this and asking the interview how
they want the function to behave on these cases.</li>
  <li><strong>Be sure to do a time complexity analysis on your solution.</strong> They want to know that
you can think about efficiency, so unless they explicitly ask you not to do this, I‚Äôd
recommend it. We‚Äôll discuss more about what this means below.</li>
</ul>

<p>For a more thorough discussion of preparation and day-of techniques, I‚Äôd recommend
<a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a>.</p>

<h2 id="tips-for-coding">Tips for Coding</h2>

<p>There are few things specifically in how the interviewee writes code that I think are
worth mentioning. This kind of stuff usually isn‚Äôt a huge deal, but if you write good
code, it can show professionalism and help leave a good impression.</p>

<ul>
  <li><strong>Name your variables well.</strong> If the variable is the average number of users per
region, use <code class="language-plaintext highlighter-rouge">num_users_per_region</code>, or <code class="language-plaintext highlighter-rouge">users_per_region</code>, not <code class="language-plaintext highlighter-rouge">avg_usr</code> or
<code class="language-plaintext highlighter-rouge">num_usr</code>. Unlike in mathematics, it‚Äôs good to have long, descriptive variables.</li>
  <li><strong>Use built-ins when you can!</strong> Python already <em>has</em> functions for sorting, for
building cartesian products of lists, for implementing various models (in
<code class="language-plaintext highlighter-rouge">statsmodels</code> and <code class="language-plaintext highlighter-rouge">scikit-learn</code>), and endless other things. It also has some cool
data structures already implemented, like the <a href="https://docs.python.org/3.7/library/heapq.html"><code class="language-plaintext highlighter-rouge">heap</code></a> and
<a href="https://docs.python.org/3/library/queue.html"><code class="language-plaintext highlighter-rouge">queue</code></a>. Get to know the <code class="language-plaintext highlighter-rouge">itertools</code> module; it has lots of usefull stuff.
if you can use these built-ins effectively, it demonstrates skill and knowledge
without adding much effort on your part.</li>
  <li><strong>Break things into functions.</strong> If one step of your code is sorting a list, and you
can‚Äôt use the built-in <code class="language-plaintext highlighter-rouge">sorted()</code> function, then write a separate function <code class="language-plaintext highlighter-rouge">def
sort()</code> before you write your main function. This increases both readability and
testability of code, and is essential for real-world software.</li>
  <li><strong>Write idiomatic Python.</strong> This is a bit less important, but make sure to iterate
directly over iterables, don‚Äôt do <code class="language-plaintext highlighter-rouge">for i in range(len(my_iterable))</code>. Also,
familiarize yourself with <code class="language-plaintext highlighter-rouge">enumerate</code> and <code class="language-plaintext highlighter-rouge">zip</code> and know how to use them. Know how to
use list compreshensions, and be aware that you can do a similar thing for
dictionaries, sets, and even arguments of functions - for example, you can do
<code class="language-plaintext highlighter-rouge">max(item for item in l if item % 2 == 0)</code> to find the maximum even number in l. Know
how to do string formatting using either <code class="language-plaintext highlighter-rouge">.format()</code> for <code class="language-plaintext highlighter-rouge">f</code>-strings in Python
3.<sup id="fnref:fnote_py3" role="doc-noteref"><a href="#fn:fnote_py3" class="footnote" rel="footnote">1</a></sup></li>
</ul>

<p>I‚Äôm only scratching the surface of how to write good code. It helps to read code that
others have written to see what you don‚Äôt know. You can also look at code in large
open-source libraries.</p>

<p>With all that said, let‚Äôs move on to some of the content that might be asked about in
these interviews.</p>

<h1 id="working-with-data">Working with Data</h1>

<p>One of the fundamental tasks of a data scientist is to load, manipulate, clean, and
visualize data in various formats. I‚Äôll go through some of the basic tasks that I think
you should be able to do, and either include or link to Python implementations. If you
work in R, or any other language, you should make sure that you can still do these
things in your preferred language.</p>

<p>In Python, the key technologies are the packages pandas (for loading, cleaning, and
manipulating data), numpy (for efficiently working with unlabeled numeric data), and
matplotlib (for plotting and visualizing data).</p>

<h2 id="loading--cleaning-data">Loading &amp; Cleaning Data</h2>

<p><a href="https://www.datacamp.com/community/tutorials/pandas-read-csv">This tutorial on DataCamp</a> nicely deals with the basics of using
<code class="language-plaintext highlighter-rouge">pd.read_csv()</code> to load data into Pandas. It is also possible to load from other
formats, but in my experience writing to and from comma- or tab-separated plaintext is
by far the most common approach for datasets that fit in memory.<sup id="fnref:fnote_parquet" role="doc-noteref"><a href="#fn:fnote_parquet" class="footnote" rel="footnote">2</a></sup></p>

<p>For example, suppose you had the following data in a csv file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name,age,country,favorite color
steve,7,US,green
jennifer,14,UK,blue
franklin,,UK,black
calvin,22,US,
</code></pre></div></div>

<p>You can copy and paste this, into Notepad or whatever text editor you
like<sup id="fnref:fnote_emacs" role="doc-noteref"><a href="#fn:fnote_emacs" class="footnote" rel="footnote">3</a></sup>, and save it as <code class="language-plaintext highlighter-rouge">data.csv</code>.</p>

<p>You should be able to</p>
<ul>
  <li>load in data from text, whether it is separated by commas, tabs, or some other
arbitrary character (sometimes things are separated by the ‚Äúpipe‚Äù character <code class="language-plaintext highlighter-rouge">|</code>). In
this case, you can just do <code class="language-plaintext highlighter-rouge">df = pd.read_csv('data.csv')</code> to load it.</li>
  <li>Filter for missing data. If you wanted to find the row(s) where the age is missing,
for example, you could do <code class="language-plaintext highlighter-rouge">df[df['age'].isnull()]</code></li>
  <li>Filter for data values. For example, to find people from the US, do <code class="language-plaintext highlighter-rouge">df[df['country'] == 'US']</code></li>
  <li>Replace missing data; use <code class="language-plaintext highlighter-rouge">df.fillna(0)</code> to replace missing data with zeros. Think for
yourself about how you would want to handle missing data in this case - does it make
sense to replace everything with zeros? What <em>would</em> make sense?</li>
</ul>

<p>Dealing with missing data is, in particular, an important problem, and not one that has
an easy answer. <a href="https://towardsdatascience.com/how-to-handle-missing-data-8646b18db0d4">Towards Data Science</a> has a decent post on this
subject, but if you‚Äôre curious, there‚Äôs a lot to read about and learn here.</p>

<p>More advanced topics in pandas-fu include <a href="https://wesmckinney.com/blog/groupby-fu-improvements-in-grouping-and-aggregating-data-in-pandas/">using <code class="language-plaintext highlighter-rouge">groupby</code></a>, joining
dataframes (this is called a ‚Äúmerge‚Äù in pandas, but works the same as a SQL join), and
<a href="https://hackernoon.com/reshaping-data-in-python-fa27dda2ff77">reshaping data</a>.</p>

<p>As I said before, loading and manipulating data is one of the fundamental tasks of a
data scientist. You should probably be comfortable doing most or all of these tasks if
asked. Pandas can be a bit unintuitive, so I‚Äôd recommend practicing if you aren‚Äôt
already comfortable with it. Doing slicing and reshaping tasks in numpy is also an
important skill, so make sure you are comfortable with that as well.</p>

<h2 id="visualization">Visualization</h2>

<p>Another essential aspect of data work is visualization. Of course, this is an entire
field unto itself; here, I‚Äôll mostly be focusing on the practical aspects of making
simple plots. If you want to start to learn more about the overarching principles of the
visual representation of data, <a href="https://www.edwardtufte.com/tufte/books_vdqi">Tufte‚Äôs book</a> is the classic in the field.</p>

<p>In Python, the fundamental tool used for data visualization is the library
<code class="language-plaintext highlighter-rouge">matplotlib</code>. There exist many other libraries for more complicated visualization tasks,
such as <code class="language-plaintext highlighter-rouge">seaborn</code>, <code class="language-plaintext highlighter-rouge">bokeh</code>, and <code class="language-plaintext highlighter-rouge">plotly</code>, but the only one that you really <em>need</em> to be
comfortable with (in my opinion) is <code class="language-plaintext highlighter-rouge">matplotlib</code>.</p>

<p>You should be comfortable with:</p>
<ul>
  <li>plotting two lists against one another</li>
  <li>changing the labels on the x- and y-axis of your plot, and adding a title</li>
  <li>changing the x- and y-limits of your plot</li>
  <li>plotting a bar graph</li>
  <li>plotting a histogram</li>
  <li>plotting two curves together, labelling them, and adding a legend</li>
</ul>

<p>I won‚Äôt go through the details here - I‚Äôm sure you can find many good guides to each of
these online. The <a href="https://matplotlib.org/3.1.1/tutorials/introductory/pyplot.html">matplotlib pyplot tutorial</a> is a good place to
start.<sup id="fnref:fnote_pyplot" role="doc-noteref"><a href="#fn:fnote_pyplot" class="footnote" rel="footnote">4</a></sup></p>

<p>It‚Äôs worth noting that you can plot directly from pandas, by doing <code class="language-plaintext highlighter-rouge">df.plot()</code>. This
just calls out to matplotlib and plots your dataframe; I will often find myself both
plotting from the pandas <code class="language-plaintext highlighter-rouge">DataFrame.plot()</code> method as well as directly using
<code class="language-plaintext highlighter-rouge">pyplot.plot()</code>. They work on the same objects, and so you can use them together to make
more complicated plots with multiple values plotted.</p>

<h1 id="data-structures--algorithms">Data Structures &amp; Algorithms</h1>

<p>Designing and building effective software is predicated on a solid understanding of the
basic data structures that are available, and familiarity with the ways that they are
employed in common algorithms. For me, learning this material opened up the world of
software engineering - it illuminated the inner workings of computer languages. It also
helped me understand the pros and cons of various approaches to problems, in ways that I
wouldn‚Äôt have been able to before.</p>

<p>This subject is fundamental to software engineering interviews, but for data scientists,
its importance can vary drastically from role to role. For engineering-heavy roles, this
material can make up half or more of the interview, while for more statistician-oriented
roles, it might only be very lightly touched upon. You will have to use your judgement
to determine to what extent this material is important to you.</p>

<p>I learned this material when I was interviewing by reading the book <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">Data Structures and
Algorithms in Python</a>.<sup id="fnref:fnote_dsa2" role="doc-noteref"><a href="#fn:fnote_dsa2" class="footnote" rel="footnote">5</a></sup> It‚Äôs really a great book - it has good, clear
explanations of all the important topics, including complexity analysis and some of the
basics of the Python language. I can‚Äôt recommend it highly enough if you want to get
more familiar with this material.<sup id="fnref:fnote_dsa" role="doc-noteref"><a href="#fn:fnote_dsa" class="footnote" rel="footnote">6</a></sup> You can buy it, or look around online for
the PDF - it shouldn‚Äôt be too hard to find.</p>

<h2 id="time-and-space-complexity-analysis">Time and Space Complexity Analysis</h2>

<p>Before you begin writing algorithms, you need to know how to analyze their
complexity. The ‚Äúcomplexity‚Äù of an algorithm tells you how the amount of time (or space)
that the algorithm takes depends on the size of the input data.</p>

<p>It is formalized using the so-called ‚Äúbig-O‚Äù notation. The precise mathematical
definition of \(\mathcal{O}(n)\) is somewhat confusing, so you can just think of it
roughly as meaning that an algorithm that is \(\mathcal{O}(n)\) ‚Äúscales like \(n\)‚Äù; so,
if you double the input size, you double the amount of time it takes. If an algorithm is
\(\mathcal{O}(n^3)\), then, doubling the input size means that you multiply the time it
takes by \(2^3 = 8\).<sup id="fnref:fnote_bigo" role="doc-noteref"><a href="#fn:fnote_bigo" class="footnote" rel="footnote">7</a></sup> You can see how even a \(\mathcal{O}(n^2)\) algorithm wouldn‚Äôt
work for large data; even if it runs in a reasonable amount of time (say, 5 seconds)for
10,000 points, it would take about 15,000 years to run on 1 billion data
points. Obviously, this is no good.</p>

<p>So complexity analysis is critical. You don‚Äôt want to settle for a \(\mathcal{O}(n^2)\)
solution when a \(\mathcal{O}(n)\) or \(\mathcal{O}(n \log n)\) solution is available. I
won‚Äôt get into how to do the analysis here, besides saying that I often like to annotate
my loops with their complexity when I‚Äôm writing things. For example, here‚Äôs a (slow)
approach to finding the largest k (unique) numbers in a list:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_top_k</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">input_list</span><span class="p">):</span>
    <span class="n">top_k</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>  <span class="c1"># happens k times
</span>        <span class="n">remaining</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">input_list</span> <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top_k</span><span class="p">]</span>  <span class="c1"># O(n)
</span>        <span class="k">if</span> <span class="n">remaining</span><span class="p">:</span>
            <span class="n">top_remaining</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span>  <span class="c1"># O(n)
</span>            <span class="n">top_k</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_remaining</span><span class="p">)</span>  <span class="c1"># O(1)
</span>    <span class="k">return</span> <span class="n">top_k</span>
</code></pre></div></div>

<p>I know that the outer loop happend <code class="language-plaintext highlighter-rouge">k</code> times, and since finding the maximum of a list is
\(\mathcal{O}(n)\), the total task is \(\mathcal{O}(nk)\).<sup id="fnref:fnote_asymptotics" role="doc-noteref"><a href="#fn:fnote_asymptotics" class="footnote" rel="footnote">8</a></sup> To learn
more about how to do complexity analysis, I‚Äôd look at <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">DS&amp;A</a>, <a href="http://www.crackingthecodinginterview.com/">Cracking the
Coding Interview</a>, or just look around online - I‚Äôm sure there are plenty of good
resources out there.</p>

<p>You can also consider not just the time of computation, but the amount of memory (space)
that your algorithm uses. This is not quite as common as time-complexity analysis, but
is still important to be able to do.</p>

<p>A very useful resource for anyone studying for a coding interview is the <a href="https://www.bigocheatsheet.com/">big-O cheat
sheet</a>, which shows the complexity of access, search, insertion, and deletion for
various data types, as well as the complexity of searching algorithms, and a lot more. I
often use it as a reference, but of course it‚Äôs important that you understand <em>why</em> (for
example) an array has \(\mathcal{O}(n)\) insertion. Just memorizing complexities won‚Äôt
help you much.</p>

<h2 id="arrays--hashmaps">Arrays &amp; Hashmaps</h2>

<p>In my opinion, the two essential data structures for a data scientist to know are
the array and the hashmap. In Python, the <code class="language-plaintext highlighter-rouge">list</code> type is an array, while the <code class="language-plaintext highlighter-rouge">dict</code> type
is a hashmap. Since both are used so commonly, you have to know their properties if you
want to be able to design efficient algorithms and do your complexity analysis
correctly.</p>

<p><strong>Arrays</strong> are a data type where a piece of data (like a string) is linked to an index
(in Python, this is an integer, starting with 0). I won‚Äôt go too deep into the details
here, but for arrays, the important thing to know is that getting any element of an
array is easy (i.e. doing <code class="language-plaintext highlighter-rouge">mylist[5]</code> is \(\mathcal{O}(1)\), so it doesn‚Äôt depend on the
size of the array) but adding elements (particularly in the beginning or middle of the
array) is difficult; doing <code class="language-plaintext highlighter-rouge">mylist.insert(k, 'foo')</code> is \(\mathcal{O}(n-k)\), where
\(k\) is the position you wish to insert at.<sup id="fnref:fnote_linked" role="doc-noteref"><a href="#fn:fnote_linked" class="footnote" rel="footnote">9</a></sup></p>

<p>Arrays are what we usually use when we‚Äôre building unordered, unlabelled collections of
objects in Python. This is fine, since insertion at the end of an array is fast, and
we‚Äôre often accessing slices of arrays in a complicated fashion (particularly in
numpy). I generally use arrays by default, without thinking too much about it, and it
generally works out alright.</p>

<p><strong>Hashmaps</strong> also link values to keys, but in this case the key can be anything you
want, rather than having to be an ordered set of integers. In Python, you build them by
specifying the key and the value, like <code class="language-plaintext highlighter-rouge">{'key': 'value'}</code>. Hashmaps are magical in that
accessing elements <em>and</em> adding elements are both
\(\mathcal{O}(1)\).<sup id="fnref:fnote_array_hashmap" role="doc-noteref"><a href="#fn:fnote_array_hashmap" class="footnote" rel="footnote">10</a></sup> Why is this cool? Well, say you wanted to
store a bunch of people‚Äôs names and ages. You might think to do a list of tuples:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">names_ages</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'Peter'</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="s">'Kat'</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="s">'Jeff'</span><span class="p">,</span> <span class="mi">41</span><span class="p">)]</span>
</code></pre></div></div>

<p>Then, if you wanted to find out Jeff‚Äôs age, you would have to iterate through the list
and find the correct tuple:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="ow">in</span> <span class="n">name_ages</span><span class="p">:</span>  <span class="c1"># happens n times
</span>    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">'Jeff'</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Jeff's age is </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>This is \(\mathcal{O}(n)\) - not very efficient. With hashmaps, you can just do</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name_ages</span> <span class="o">=</span> <span class="p">{</span><span class="s">'Peter'</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s">'Kat'</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="s">'Jeff'</span><span class="p">:</span> <span class="mi">41</span><span class="p">}</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Jeff's age is </span><span class="si">{</span><span class="n">name_ages</span><span class="p">[</span><span class="s">'Jeff'</span><span class="p">]</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>  <span class="c1"># O(1)! Wow!
</span></code></pre></div></div>

<p>It might not be obvious how cool this is until you see how to use it in
problems. <a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a> has lots of good problems on hashmaps,
but I‚Äôll just reproduce some of the classics here. I think it‚Äôs worth knowing these,
because they really can give you an intuitive sense of when and how hashmaps are
valuable.</p>

<p>The first classic hashmap algorithm is <strong>counting frequencies of items in a list.</strong> That
is, given a list, you want to know how many times each item appears. You can do this via
the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_freqs</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>  <span class="c1"># happens O(n) times
</span>        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">freqs</span><span class="p">:</span>  <span class="c1"># This check is O(1)! Wow!
</span>            <span class="n">freqs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Also O(1)! Wow!
</span>    <span class="k">return</span> <span class="n">freqs</span>
</code></pre></div></div>

<p>Try and think of how you‚Äôd do this <em>without</em> hashmaps. Probably, you‚Äôd sort the list,
and then look at adjacent values. But sorting is, at best \(\mathcal{O}(\log n)\). This
solution does it in \(\mathcal{O}(n)\)!</p>

<p>Another classic problem that is solved with hashmaps is to <strong>find all repeated elements
in a list.</strong> This is really just a variant of the last, where you look for elements that
have frequency greater than 1.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_repeated</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">get_freqs</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">f</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>Now, if you only need <em>one</em> repeated element, you can be efficient and just terminate on
the first one you find. For this, we‚Äôll use a <code class="language-plaintext highlighter-rouge">set</code>, which is just a <code class="language-plaintext highlighter-rouge">dict</code> with values
of <code class="language-plaintext highlighter-rouge">None</code>. That is to say, <strong>sets are also hashmaps</strong>. The important thing to know is
that adding to them and checking if something is in them are both \(\mathcal{O}(1)\).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_repeated</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>  <span class="c1"># happens O(n) times
</span>        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>  <span class="c1"># This check is O(1)! Wow!
</span>            <span class="n">items</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span>  <span class="c1"># if this happens, all elements are unique
</span></code></pre></div></div>

<p>The last one we‚Äôll do is a bit trickier. You‚Äôre given a list of numbers, and a ‚Äútarget‚Äù,
and your task is to find a pair of numbers in the list that add up to the target. Try
and think for yourself how you‚Äôd do this - the fact you use hashmaps is a big hint. You
should be able to do it in \(\mathcal{O}(n)\).</p>

<p>Have you thought about it? When I first encountered this one I had to look up the
answer. But here‚Äôs how you do it in \(\mathcal{O}(n)\):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_sum_pair</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">nums_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="n">other_num</span> <span class="o">=</span> <span class="n">target</span><span class="o">-</span><span class="n">num</span>
        <span class="k">if</span> <span class="n">other_num</span> <span class="ow">in</span> <span class="n">nums_set</span><span class="p">:</span> 
            <span class="k">return</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">other_num</span><span class="p">)</span>
        <span class="n">nums_set</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>   <span class="c1"># no-op if num is already there
</span>    <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">other_num = target-num</code> is the number that you would need to complete the sum
pair; using a hashmap, you can check in \(\mathcal{O}(1)\) if you‚Äôve already seen it!
Wow!</p>

<p>Hopefully you get it - hashmaps are cool. Go on LeetCode, or pop open <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">your favorite
data structures book</a>, or even <a href="http://www.crackingthecodinginterview.com/">Cracking the Coding Interview</a>, and
get some practice with them.</p>

<h2 id="sorting--searching">Sorting &amp; Searching</h2>

<p>Sorting and searching are two of the basic tasks you have to be familiar with for any
coding interview. You can go into a lot of depth with these, but I‚Äôll stick to the
basics here, because that‚Äôs what I find most helpful.</p>

<h3 id="sorting">Sorting</h3>

<p><strong>Sorting</strong> is a nice problem in that the statement of the problem is fairly
straightforward; given a list of numbers, reorder the list so that every element is less
than or equal to the next. There are a number of approaches to sorting. The naive
approach is called <a href="https://en.wikipedia.org/wiki/Insertion_sort"><strong>insertion sort</strong></a>; for example, it is what most people
do when sorting a hand of cards. It has some advantages, but is \(\mathcal{O}(n^2)\) in
time, and so is not the most efficient available.</p>

<p>The two most common fast sorting algorithms are <a href="https://en.wikipedia.org/wiki/Quicksort"><strong>quicksort</strong></a> and
<a href="https://en.wikipedia.org/wiki/Merge_sort"><strong>mergesort</strong></a>. They are both \(\mathcal{O}(n \log n)\) in
time,<sup id="fnref:fnote_sort" role="doc-noteref"><a href="#fn:fnote_sort" class="footnote" rel="footnote">11</a></sup> and so scale close-to-linearly with the size of the list. I won‚Äôt go
into the implementation details here; there are plenty of good discussions of them
available on the internet.</p>

<p>When thinking about sorting, it‚Äôs also worth considering space complexity -
can you sort without needing to carry around a second sorted copy of the list? If so,
that‚Äôs a significant advantage, especially for larger lists. It‚Äôs also worth thinking
about worst-case vs. average performance - how does the algorithm perform on a randomly
shuffled list, and how does it perform on a list specifically designed to take the
maximum number of steps for that algorithm to sort? Quicksort, for example, is actually
\(\mathcal{O}(n^2)\) in the worst case, but is \(\mathcal{O}(n \log n)\) on
average. Again, you can look to the <a href="https://www.bigocheatsheet.com/">big-O cheat sheet</a> to make sure you‚Äôre
remembering all your complexities correctly.</p>

<h3 id="searching">Searching</h3>

<p>The problem of <strong>searching</strong> is often stated as <strong>given a sorted list <code class="language-plaintext highlighter-rouge">l</code> and an object
<code class="language-plaintext highlighter-rouge">x</code>, find the index at which an element <code class="language-plaintext highlighter-rouge">x</code> lives.</strong> (You should immediately ask: What
should I return if <code class="language-plaintext highlighter-rouge">x</code> is not in <code class="language-plaintext highlighter-rouge">l</code>?)The name of the game here is <strong>binary
search</strong>. You basically split the list, then if the number is greater than the split,
search the top; otherwise, search the bottom. This is an example of a <em>recursive
algorithm</em>, so the way it‚Äôs written can be a bit opaque to those not used to looking at
recursive code. Once I can wrap my head around it, I find it quite elegant. The
important thing to know is that this search is \(\mathcal{O}(\log n)\), which means that
you don‚Äôt touch every element in the list - it‚Äôs very fast, even for a large list. The
key to this is that the list is already sorted - if it‚Äôs not sorted, then you‚Äôre out of
luck; you‚Äôve got to check every element to find <code class="language-plaintext highlighter-rouge">x</code>.</p>

<p>There are tons of examples of binary search in Python online, so I won‚Äôt put one
here. That said, I have found it interesting to see how thinking in terms of binary
search can help you in a variety of areas.</p>

<p>For example, suppose you had some eggs, and worked in a 40-story building, and wanted to
know the highest floor you could drop the egg off of without it breaking (it‚Äôs kind of a
dumb example cause the egg would probably break even on the first floor, but pretend
it‚Äôs a super-tough egg.) You could drop it from the first floor, and see what
happens. Say it doesn‚Äôt break. Then drop it from the 40th, and see what happens. Say it
does break. Then, you bisect and use the midpoint - drop from the 20th floor. If it
breaks here, you next try the 10th - if it doesn‚Äôt you next try the 30th. This allows
you to find the correct floor much faster than trying each floor in succession.</p>

<p>Sorting and searching are fundamental algorithms, and have been well studied for
decades. Having a basic fluency in them shows a familiarity with the field of computers
science that many employers like to see. In my opinion, <strong>you should be able to quickly
and easily implement the three sorting algorithms above, and binary search,</strong> in Python,
or whatever your language of choice is.</p>

<h1 id="working-with-sql">Working with SQL</h1>

<p>Finally, let‚Äôs talk a bit about SQL. SQL is a tool used to interact with so-called
‚Äúrelational‚Äù databases, which just means that each row in a table has certain values
(columns), and that those values have the same type for each row (that is, the schema is
uniform throughout the table).<sup id="fnref:fnote_nosql" role="doc-noteref"><a href="#fn:fnote_nosql" class="footnote" rel="footnote">12</a></sup> It is not exactly a language, it‚Äôs more
like a family of languages. There are many ‚Äúdialects‚Äù which all have slight differences,
but they behave the same with regards to core functionality; for example, you can do</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">column</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">columns</span> <span class="o">=</span> <span class="s1">'value'</span>
</code></pre></div></div>

<p>in any SQL-like language.<sup id="fnref:fnote_ansi" role="doc-noteref"><a href="#fn:fnote_ansi" class="footnote" rel="footnote">13</a></sup> Modern data-storage and -access solutions like
Spark and Presto are very different from older databases in their underlying
architecture, but still use a SQL dialect for accessing data.</p>

<p>Solving problems in SQL involves thinking in a quite different way than solving a
similar problem on an array in Python. There is no real notion of iteration, or at least
it‚Äôs not easily accessible, so most of the complicated action happens via table joins. I
used <a href="https://sqlzoo.net/">SQLZoo</a>, and particularly the ‚Äúassessments‚Äù, to practice my SQL and get it
up to snuff. LeetCode also has a SQL section (I think they call it ‚Äúdatabase‚Äù).</p>

<p>It‚Äôs essential to know SQL as a working data scientist. You‚Äôll almost certainly use it
in your day-to-day activities. That said, it‚Äôs not always asked in the interviews, so
you might clarify with the company whether they will ask you SQL questions.</p>

<h2 id="a-note-on-dialects">A Note on Dialects</h2>

<p>There are many dialects of SQL, and changing the dialect changes things like (for
example) how you work with dates. It‚Äôs worth asking the company you‚Äôre interviewing with
what dialect they want you to know, if they have one in mind. If you‚Äôre just writing SQL
on a whiteboard, then I would be surprised if they were picky about this; I would just
say something like ‚Äúhere I‚Äôd use <code class="language-plaintext highlighter-rouge">DATE(table.dt_str)</code> or whatever the string-to-date
conversion function is in your dialect‚Äù. In this case it‚Äôs just details that move
around, but the big picture is generally the same for different dialects.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Coding interviews are stressful. From what I can tell, that‚Äôs just the way it is. For
me, the best antidote to that is being well-prepared. I think companies are moving more
towards constructive, cooperative interview formats, and away from the classic Google
brain-teaser kind of questions, which helps with this, but you can still expect to be
challenged during these interviews.</p>

<p>Remember to be kind to yourself. You‚Äôll probably fail many times before you
succeed. That‚Äôs fine, and is what happens to almost everyone. Just keep practicing, and
keep learning from your mistakes. Good luck!</p>

<!-------------------------------- FOOTER ---------------------------->

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fnote_py3" role="doc-endnote">
      <p>You should be using Python 3 at this point, but also be familiar with the
differences between 2 and 3, and be able to write code in Python 2 if need be.¬†<a href="#fnref:fnote_py3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_parquet" role="doc-endnote">
      <p>For ‚Äúbig data‚Äù stored in the cloud, an efficient format called Parquet
is the standard. In my experience, however, it‚Äôs uncommon to work with parquet files
directly in Pandas; you often read them into a distributed framework like Spark and work
with them in that context.¬†<a href="#fnref:fnote_parquet" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_emacs" role="doc-endnote">
      <p>The correct answer is, of course, emacs.¬†<a href="#fnref:fnote_emacs" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_pyplot" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">pyplot</code> is an API within matplotlib that was designed in order to
mimic the MATLAB plotting API. It is generally what I use; I begin most of my matplotlib
work with <code class="language-plaintext highlighter-rouge">from matplotlib import pyplot as plt</code>. I only rarely need to <code class="language-plaintext highlighter-rouge">import
matplotlib</code> direct, and that‚Äôs generally for configuration work.¬†<a href="#fnref:fnote_pyplot" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_dsa2" role="doc-endnote">
      <p>I read the book when preparing for a software engineer interview at
Google, so I picked up a lot more than was necessary for a data science interview. I
still find the material helpful, however, and it‚Äôs nice to be able to demonstrate
that you have gone above and beyond in a realm that data scientists sometimes
neglect (efficient software design).¬†<a href="#fnref:fnote_dsa2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_dsa" role="doc-endnote">
      <p>It goes well beyond what you‚Äôll need for a data science interview,
however - it gets into tree structures, graphs (and graph traversal algorithms), and
other more advanced topics. I‚Äôd recommend focusing on complexity analysis, arrays,
and hashmaps as the most important data structures that a data scientist will use
day-to-day.¬†<a href="#fnref:fnote_dsa" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_bigo" role="doc-endnote">
      <p>This is only approximately true, or rather it is is <em>asymptotically</em>
true; this scaling law holds in the limit as \(n\rightarrow\infty\).¬†<a href="#fnref:fnote_bigo" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_asymptotics" role="doc-endnote">
      <p>It‚Äôs a bit weird to use <em>both</em> \(n\) and \(k\) in your
complexity - mathematically, what this means is that we consider them separate
variables , and we can take the limit of either one independently from the
other. If, for example, you knew that \(k = n/4\), so you always wanted the top
quarter of the list, then this would be \(\mathcal{O}(n^2)\), since \(n/4 =
\mathcal{O}(n)\).¬†<a href="#fnref:fnote_asymptotics" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_linked" role="doc-endnote">
      <p>I‚Äôm glossing over some details here - the numbers I quote above are for
a fixed-size array. So, if you build up an array by adding elements at the end, it
may seem like you get to just do a bunch of \(\mathcal{O}(1)\) <code class="language-plaintext highlighter-rouge">.append</code>s, but in
reality, you have to occasionally resize the array to make more space, which slows
things down to an average append time of \(\mathcal{O}(n)\). If you want a list-like
type where inserting elements is easy (\(\mathcal{O}(1)\)) but accessing elements is
difficult (\(\mathcal{O}(n)\)), then you want a <em>linked list</em>. Linked lists aren‚Äôt
as important for data scientists to use, so I won‚Äôt get into them much here.¬†<a href="#fnref:fnote_linked" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_array_hashmap" role="doc-endnote">
      <p>You might wonder why we would ever use an array over a hashmap
if hashmaps are strictly superior with respect to their complexity. It‚Äôs a good
question. The answer is that arrays take up less space (they don‚Äôt have to store the
keys, only the values) and they are much easier to work with in code (they look
cleaner, and are more intuitive for unordered data). Furthermore, if you had a
hashmap that linked integers <code class="language-plaintext highlighter-rouge">0</code> through <code class="language-plaintext highlighter-rouge">10</code> to strings, and you wanted to change
the element at key <code class="language-plaintext highlighter-rouge">5</code>, then you‚Äôd have to go through what is currently at keys
<code class="language-plaintext highlighter-rouge">5</code> through <code class="language-plaintext highlighter-rouge">10</code>, and increment their keys by one, so you would end up back at an
inefficient insertion algorithm like you have with arrays.¬†<a href="#fnref:fnote_array_hashmap" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_sort" role="doc-endnote">
      <p>This is true <em>on average</em>; see the section below for a discussion of
average vs. worst-case complexity.¬†<a href="#fnref:fnote_sort" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_nosql" role="doc-endnote">
      <p>Non-relational database formats, like HBase and NoSQL, basically
function like giant hashmaps; they have a single ‚Äúkey‚Äù, and then the ‚Äúvalue‚Äù can
contain arbitrary data - you don‚Äôt have to have certain columns in there. The
advantage of this is flexibility, but the disadvantage is that sorting and filtering
are slower because the database doesn‚Äôt have a pre-defined schema.¬†<a href="#fnref:fnote_nosql" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fnote_ansi" role="doc-endnote">
      <p>Technically, SQL is an ANSI Standard that many different dialects
implement - so, to call yourself a SQL dialect, you must have features defined by
this standard, like the <code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">FROM</code>, and <code class="language-plaintext highlighter-rouge">WHERE</code> clauses shown above.¬†<a href="#fnref:fnote_ansi" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET